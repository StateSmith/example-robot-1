// Autogenerated with StateSmith 0.13.2+aa5928542b575391637cb5e1a7821184f6c3932c.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

    
#include "BotSm.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset
    

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(BotSm* sm, BotSm_StateId desired_state);

static void ROOT_enter(BotSm* sm);

static void E_STOP_enter(BotSm* sm);

static void E_STOP_exit(BotSm* sm);

static void E_STOP_any_key(BotSm* sm);

static void E_STOP_do(BotSm* sm);

static void REGULAR_enter(BotSm* sm);

static void REGULAR_exit(BotSm* sm);

static void REGULAR_any_key(BotSm* sm);

static void CLEAN_KITCHEN_enter(BotSm* sm);

static void CLEAN_KITCHEN_exit(BotSm* sm);

static void DROP_FOOD_enter(BotSm* sm);

static void DROP_FOOD_exit(BotSm* sm);

static void DROP_FOOD_do(BotSm* sm);

static void FEED_enter(BotSm* sm);

static void FEED_exit(BotSm* sm);

static void FEED_do(BotSm* sm);

static void MOVE_LEFT_enter(BotSm* sm);

static void MOVE_LEFT_exit(BotSm* sm);

static void MOVE_LEFT_do(BotSm* sm);

static void PICKUP_enter(BotSm* sm);

static void PICKUP_exit(BotSm* sm);

static void PICKUP_do(BotSm* sm);

static void PUSH_FOOD_enter(BotSm* sm);

static void PUSH_FOOD_exit(BotSm* sm);

static void PUSH_FOOD_do(BotSm* sm);

static void REMIND_RESTART_enter(BotSm* sm);

static void REMIND_RESTART_exit(BotSm* sm);

static void REMIND_RESTART_any_key(BotSm* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void BotSm_ctor(BotSm* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void BotSm_start(BotSm* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(REGULAR)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `REGULAR`.
            REGULAR_enter(sm);
            
            // REGULAR.<InitialState> behavior
            // uml: TransitionTo(PICKUP)
            {
                // Step 1: Exit states until we reach `REGULAR` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `PICKUP`.
                PICKUP_enter(sm);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for REGULAR.<InitialState>
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
// Note! This function assumes that the `event_id` parameter is valid.
void BotSm_dispatch_event(BotSm* sm, BotSm_EventId event_id)
{
    switch (sm->state_id)
    {
        // STATE: BotSm
        case BotSm_StateId_ROOT:
            switch (event_id)
            {
                // Events not handled by this state:
                case BotSm_EventId_ANY_KEY: break;
                case BotSm_EventId_DO: break;
            }
            break;
        
        // STATE: E_STOP
        case BotSm_StateId_E_STOP:
            switch (event_id)
            {
                case BotSm_EventId_DO: E_STOP_do(sm); break;
                case BotSm_EventId_ANY_KEY: E_STOP_any_key(sm); break;
            }
            break;
        
        // STATE: REGULAR
        case BotSm_StateId_REGULAR:
            switch (event_id)
            {
                case BotSm_EventId_ANY_KEY: REGULAR_any_key(sm); break;
                // Events not handled by this state:
                case BotSm_EventId_DO: break;
            }
            break;
        
        // STATE: CLEAN_KITCHEN
        case BotSm_StateId_CLEAN_KITCHEN:
            switch (event_id)
            {
                // Events not handled by this state:
                case BotSm_EventId_ANY_KEY: REGULAR_any_key(sm); break; // First ancestor handler for this event
                case BotSm_EventId_DO: break;
            }
            break;
        
        // STATE: DROP_FOOD
        case BotSm_StateId_DROP_FOOD:
            switch (event_id)
            {
                case BotSm_EventId_DO: DROP_FOOD_do(sm); break;
                // Events not handled by this state:
                case BotSm_EventId_ANY_KEY: REGULAR_any_key(sm); break; // First ancestor handler for this event
            }
            break;
        
        // STATE: FEED
        case BotSm_StateId_FEED:
            switch (event_id)
            {
                case BotSm_EventId_DO: FEED_do(sm); break;
                // Events not handled by this state:
                case BotSm_EventId_ANY_KEY: REGULAR_any_key(sm); break; // First ancestor handler for this event
            }
            break;
        
        // STATE: MOVE_LEFT
        case BotSm_StateId_MOVE_LEFT:
            switch (event_id)
            {
                case BotSm_EventId_DO: MOVE_LEFT_do(sm); break;
                // Events not handled by this state:
                case BotSm_EventId_ANY_KEY: REGULAR_any_key(sm); break; // First ancestor handler for this event
            }
            break;
        
        // STATE: PICKUP
        case BotSm_StateId_PICKUP:
            switch (event_id)
            {
                case BotSm_EventId_DO: PICKUP_do(sm); break;
                // Events not handled by this state:
                case BotSm_EventId_ANY_KEY: REGULAR_any_key(sm); break; // First ancestor handler for this event
            }
            break;
        
        // STATE: PUSH_FOOD
        case BotSm_StateId_PUSH_FOOD:
            switch (event_id)
            {
                case BotSm_EventId_DO: PUSH_FOOD_do(sm); break;
                // Events not handled by this state:
                case BotSm_EventId_ANY_KEY: REGULAR_any_key(sm); break; // First ancestor handler for this event
            }
            break;
        
        // STATE: REMIND_RESTART
        case BotSm_StateId_REMIND_RESTART:
            switch (event_id)
            {
                case BotSm_EventId_ANY_KEY: REMIND_RESTART_any_key(sm); break;
                // Events not handled by this state:
                case BotSm_EventId_DO: break;
            }
            break;
    }
    
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(BotSm* sm, BotSm_StateId desired_state)
{
    while (sm->state_id != desired_state)
    {
        switch (sm->state_id)
        {
            case BotSm_StateId_E_STOP: E_STOP_exit(sm); break;
            
            case BotSm_StateId_REGULAR: REGULAR_exit(sm); break;
            
            case BotSm_StateId_CLEAN_KITCHEN: CLEAN_KITCHEN_exit(sm); break;
            
            case BotSm_StateId_DROP_FOOD: DROP_FOOD_exit(sm); break;
            
            case BotSm_StateId_FEED: FEED_exit(sm); break;
            
            case BotSm_StateId_MOVE_LEFT: MOVE_LEFT_exit(sm); break;
            
            case BotSm_StateId_PICKUP: PICKUP_exit(sm); break;
            
            case BotSm_StateId_PUSH_FOOD: PUSH_FOOD_exit(sm); break;
            
            case BotSm_StateId_REMIND_RESTART: REMIND_RESTART_exit(sm); break;
            
            default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(BotSm* sm)
{
    sm->state_id = BotSm_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state E_STOP
////////////////////////////////////////////////////////////////////////////////

static void E_STOP_enter(BotSm* sm)
{
    sm->state_id = BotSm_StateId_E_STOP;
    
    // E_STOP behavior
    // uml: (enter, do) / { safe_machine(); }
    {
        // Step 1: execute action `safe_machine();`
        safe_machine();
    } // end of behavior for E_STOP
    
    // E_STOP behavior
    // uml: enter / { speak("Well crap. What happened?"); }
    {
        // Step 1: execute action `speak("Well crap. What happened?");`
        speak("Well crap. What happened?");
    } // end of behavior for E_STOP
}

static void E_STOP_exit(BotSm* sm)
{
    sm->state_id = BotSm_StateId_ROOT;
}

static void E_STOP_any_key(BotSm* sm)
{
    // E_STOP behavior
    // uml: ANY_KEY [is_speaking_done()] TransitionTo(REMIND_RESTART)
    if (is_speaking_done())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        E_STOP_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `REMIND_RESTART`.
        REMIND_RESTART_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for E_STOP
    
    // No ancestor handles this event.
}

static void E_STOP_do(BotSm* sm)
{
    // E_STOP behavior
    // uml: (enter, do) / { safe_machine(); }
    {
        // Step 1: execute action `safe_machine();`
        safe_machine();
    } // end of behavior for E_STOP
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state REGULAR
////////////////////////////////////////////////////////////////////////////////

static void REGULAR_enter(BotSm* sm)
{
    sm->state_id = BotSm_StateId_REGULAR;
}

static void REGULAR_exit(BotSm* sm)
{
    // REGULAR behavior
    // uml: exit / { sequence_abort(); }
    {
        // Step 1: execute action `sequence_abort();`
        sequence_abort();
    } // end of behavior for REGULAR
    
    sm->state_id = BotSm_StateId_ROOT;
}

static void REGULAR_any_key(BotSm* sm)
{
    // REGULAR behavior
    // uml: ANY_KEY TransitionTo(E_STOP)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, BotSm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `E_STOP`.
        E_STOP_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for REGULAR
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CLEAN_KITCHEN
////////////////////////////////////////////////////////////////////////////////

static void CLEAN_KITCHEN_enter(BotSm* sm)
{
    sm->state_id = BotSm_StateId_CLEAN_KITCHEN;
    
    // CLEAN_KITCHEN behavior
    // uml: enter / { sequence_start(SSI_CLEAN_KITCHEN); }
    {
        // Step 1: execute action `sequence_start(SSI_CLEAN_KITCHEN);`
        sequence_start(SSI_CLEAN_KITCHEN);
    } // end of behavior for CLEAN_KITCHEN
}

static void CLEAN_KITCHEN_exit(BotSm* sm)
{
    sm->state_id = BotSm_StateId_REGULAR;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state DROP_FOOD
////////////////////////////////////////////////////////////////////////////////

static void DROP_FOOD_enter(BotSm* sm)
{
    sm->state_id = BotSm_StateId_DROP_FOOD;
    
    // DROP_FOOD behavior
    // uml: enter / { sequence_start(SSI_DROP_FOOD); }
    {
        // Step 1: execute action `sequence_start(SSI_DROP_FOOD);`
        sequence_start(SSI_DROP_FOOD);
    } // end of behavior for DROP_FOOD
}

static void DROP_FOOD_exit(BotSm* sm)
{
    sm->state_id = BotSm_StateId_REGULAR;
}

static void DROP_FOOD_do(BotSm* sm)
{
    // DROP_FOOD behavior
    // uml: do [is_sequence_complete()] TransitionTo(CLEAN_KITCHEN)
    if (is_sequence_complete())
    {
        // Step 1: Exit states until we reach `REGULAR` state (Least Common Ancestor for transition).
        DROP_FOOD_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CLEAN_KITCHEN`.
        CLEAN_KITCHEN_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for DROP_FOOD
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state FEED
////////////////////////////////////////////////////////////////////////////////

static void FEED_enter(BotSm* sm)
{
    sm->state_id = BotSm_StateId_FEED;
    
    // FEED behavior
    // uml: enter / { sequence_start(SSI_FEED); }
    {
        // Step 1: execute action `sequence_start(SSI_FEED);`
        sequence_start(SSI_FEED);
    } // end of behavior for FEED
}

static void FEED_exit(BotSm* sm)
{
    sm->state_id = BotSm_StateId_REGULAR;
}

static void FEED_do(BotSm* sm)
{
    // FEED behavior
    // uml: do [is_sequence_complete()] TransitionTo(PUSH_FOOD)
    if (is_sequence_complete())
    {
        // Step 1: Exit states until we reach `REGULAR` state (Least Common Ancestor for transition).
        FEED_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PUSH_FOOD`.
        PUSH_FOOD_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for FEED
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MOVE_LEFT
////////////////////////////////////////////////////////////////////////////////

static void MOVE_LEFT_enter(BotSm* sm)
{
    sm->state_id = BotSm_StateId_MOVE_LEFT;
    
    // MOVE_LEFT behavior
    // uml: enter / { sequence_start(SSI_MOVE_LEFT); }
    {
        // Step 1: execute action `sequence_start(SSI_MOVE_LEFT);`
        sequence_start(SSI_MOVE_LEFT);
    } // end of behavior for MOVE_LEFT
}

static void MOVE_LEFT_exit(BotSm* sm)
{
    sm->state_id = BotSm_StateId_REGULAR;
}

static void MOVE_LEFT_do(BotSm* sm)
{
    // MOVE_LEFT behavior
    // uml: do [is_sequence_complete()] TransitionTo(FEED)
    if (is_sequence_complete())
    {
        // Step 1: Exit states until we reach `REGULAR` state (Least Common Ancestor for transition).
        MOVE_LEFT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `FEED`.
        FEED_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MOVE_LEFT
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PICKUP
////////////////////////////////////////////////////////////////////////////////

static void PICKUP_enter(BotSm* sm)
{
    sm->state_id = BotSm_StateId_PICKUP;
    
    // PICKUP behavior
    // uml: enter / { sequence_start(SSI_PICKUP); }
    {
        // Step 1: execute action `sequence_start(SSI_PICKUP);`
        sequence_start(SSI_PICKUP);
    } // end of behavior for PICKUP
}

static void PICKUP_exit(BotSm* sm)
{
    sm->state_id = BotSm_StateId_REGULAR;
}

static void PICKUP_do(BotSm* sm)
{
    // PICKUP behavior
    // uml: do [is_sequence_complete()] TransitionTo(MOVE_LEFT)
    if (is_sequence_complete())
    {
        // Step 1: Exit states until we reach `REGULAR` state (Least Common Ancestor for transition).
        PICKUP_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MOVE_LEFT`.
        MOVE_LEFT_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for PICKUP
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PUSH_FOOD
////////////////////////////////////////////////////////////////////////////////

static void PUSH_FOOD_enter(BotSm* sm)
{
    sm->state_id = BotSm_StateId_PUSH_FOOD;
    
    // PUSH_FOOD behavior
    // uml: enter / { sequence_start(SSI_PUSH_FOOD); }
    {
        // Step 1: execute action `sequence_start(SSI_PUSH_FOOD);`
        sequence_start(SSI_PUSH_FOOD);
    } // end of behavior for PUSH_FOOD
}

static void PUSH_FOOD_exit(BotSm* sm)
{
    sm->state_id = BotSm_StateId_REGULAR;
}

static void PUSH_FOOD_do(BotSm* sm)
{
    // PUSH_FOOD behavior
    // uml: do [is_sequence_complete()] TransitionTo(DROP_FOOD)
    if (is_sequence_complete())
    {
        // Step 1: Exit states until we reach `REGULAR` state (Least Common Ancestor for transition).
        PUSH_FOOD_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `DROP_FOOD`.
        DROP_FOOD_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for PUSH_FOOD
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state REMIND_RESTART
////////////////////////////////////////////////////////////////////////////////

static void REMIND_RESTART_enter(BotSm* sm)
{
    sm->state_id = BotSm_StateId_REMIND_RESTART;
    
    // REMIND_RESTART behavior
    // uml: enter / { speak("Please reset me."); }
    {
        // Step 1: execute action `speak("Please reset me.");`
        speak("Please reset me.");
    } // end of behavior for REMIND_RESTART
}

static void REMIND_RESTART_exit(BotSm* sm)
{
    sm->state_id = BotSm_StateId_ROOT;
}

static void REMIND_RESTART_any_key(BotSm* sm)
{
    // REMIND_RESTART behavior
    // uml: ANY_KEY [is_speaking_done()] TransitionTo(REMIND_RESTART)
    if (is_speaking_done())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        REMIND_RESTART_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `REMIND_RESTART`.
        REMIND_RESTART_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for REMIND_RESTART
    
    // No ancestor handles this event.
}

// Thread safe.
char const * BotSm_state_id_to_string(BotSm_StateId id)
{
    switch (id)
    {
        case BotSm_StateId_ROOT: return "ROOT";
        case BotSm_StateId_E_STOP: return "E_STOP";
        case BotSm_StateId_REGULAR: return "REGULAR";
        case BotSm_StateId_CLEAN_KITCHEN: return "CLEAN_KITCHEN";
        case BotSm_StateId_DROP_FOOD: return "DROP_FOOD";
        case BotSm_StateId_FEED: return "FEED";
        case BotSm_StateId_MOVE_LEFT: return "MOVE_LEFT";
        case BotSm_StateId_PICKUP: return "PICKUP";
        case BotSm_StateId_PUSH_FOOD: return "PUSH_FOOD";
        case BotSm_StateId_REMIND_RESTART: return "REMIND_RESTART";
        default: return "?";
    }
}

// Thread safe.
char const * BotSm_event_id_to_string(BotSm_EventId id)
{
    switch (id)
    {
        case BotSm_EventId_ANY_KEY: return "ANY_KEY";
        case BotSm_EventId_DO: return "DO";
        default: return "?";
    }
}
